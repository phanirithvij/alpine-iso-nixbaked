#!/usr/bin/env python3
#
# -*- coding: utf-8 -*-
# TeaISO - ISO generation tool for Arch Linux.
# License: GPL-3

#TODO: Fix hooks for Ventoy.
import argparse
import os
import sys
import shutil
import yaml
import time
import logging
from datetime import date, datetime
import glob
from collections import OrderedDict

sys.path.insert(0,"/usr/lib/teaiso")


if os.getuid() != 0:
    logging.error("You need to have root privileges to run this script!")
    sys.exit(1)

VERSION = "1.1.2"
compression_types = ['gzip', 'xz', 'lzma', 'lzo', 'lz4', 'zstd']
logging.basicConfig(handlers=[logging.FileHandler("/var/log/teaiso.log"), logging.StreamHandler()],
                    format='%(asctime)s [mkteaiso] %(levelname)s: %(message)s', datefmt='%d/%m/%y %H:%M:%S')

# Argument Parser
def arguments():
    description = "ISO creation tool for Arch Linux, v{0}".format(VERSION)
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument(
        "-o", "--output",
        help="Output directory of ISO.",
    )
    parser.add_argument(
        "-w", "--work",
        help="Work directory of ISOs preparation files.",
    )
    parser.add_argument(
        "-c", "--compression",
        help="Compression type of squashfs.",
    )
    parser.add_argument(
        "-v", "--verbose",
        help="Enable detailed verbose output.",
        action="store_true")
    parser.add_argument(
        "-p", "--profile",
        help="Profile directory for ISO.",
        required=True
    )

    return parser.parse_args()


def execute_command(command,vital=True):
    process = os.system(command)
    if vital and process!=0:
        logging.error("-> "+command)
        logging.error("Process exited with {}".format(str(process)))
        sys.exit(process)
    return process


def run_chroot(command, path="/dev/stdout",vital=True):
    command = command.replace('"', "'").strip()
    target = work_directory + '/' + iso_profile["arch"]
    
    return execute_command('chroot {} /bin/sh -c "{}" > {}'.format(target, command, path),vital)

def remove_all_contents(directory):
	    for path in glob.glob(directory):
	        if os.path.isfile(path):
	            os.remove(path)
	        elif os.path.isdir(path):
	            shutil.rmtree(path)
             

# Read profile arguments
def read_profile(directory_original):
    logging.info('Reading profile...')

    directory = os.path.realpath(directory_original) + "/"
    file_name = directory + "profile.yaml"

    if os.path.exists(file_name):
        file = open(file_name).read()

        try:
            contents = yaml.load(file, Loader=yaml.FullLoader)

            name = contents["name"]
            distro = contents["distro"]
            publisher = contents["publisher"]
            label = contents["label"]
            application_id = contents["application_id"]
            airootfs_directory = directory + contents["airootfs_directory"]
            arch = contents["arch"]
            if distro == 'archlinux':
                pacman_directory = directory + contents["pacman"]
            else:
                pacman_directory = None
            grub_cfg = directory + contents["grub_cfg"]

            all_packages = []
            for package in contents["packages"]:
                package_names = open(directory + package).read().split("\n")
                [ all_packages.append(str(p)) for p in package_names if not(p.startswith('#'))]
                
            all_packages = list(OrderedDict.fromkeys(all_packages))

            file_permissions = {}
            for file in contents["file_permissions"]:
                file = file.split("|")
                file_permissions[file[0]] = file[1]

            customize_airootfs = {}
            for source in contents["customize_airootfs"]:
                if os.path.exists(directory + source):
                    customize_airootfs[os.path.basename(source)] = directory + source
                else:
                    exit("{} doesn't exists!".format(directory + source))

            logging.info('Done!')
            return {"name": name, "publisher": publisher, "label": label,
                    "application_id": application_id, "airootfs_directory": airootfs_directory, "arch": arch,
                    "pacman_directory": pacman_directory, "grub_cfg": grub_cfg, "all_packages": all_packages,
                    "file_permissions": file_permissions, "customize_airootfs": customize_airootfs, "distro": distro}
        except (TypeError, KeyError):
            logging.error('profile.yaml corrupted. Please, fix it!')
            sys.exit(1)
    else:
        logging.error('profile.yaml doesn\'t exists in {} directory!'.format(directory))
        sys.exit(1)


def create_directories():
    if not os.path.exists(work_directory):
        os.mkdir(work_directory)
        logging.info("Work directory created!")
    else:
        logging.info("Work directory already exists!")
        
    if not os.path.exists(output_directory):
        os.mkdir(output_directory)
        logging.info("Output directory created!")
    else:
        logging.info("Output directory already exists!")
    
    change_status("create_directories")
    


def make_custom_airootfs():
    execute_command("mkdir -p \"{}\"".format(target))
    execute_command("cp -prf --no-preserve=ownership \"{}\"/* \"{}\"/".format(iso_profile["airootfs_directory"], target))

    os.chmod(target + '/etc/shadow', 0o400) if os.path.exists(target + '/etc/shadow') else None
    os.chmod(target + '/etc/gshadow', 0o400) if os.path.exists(target + '/etc/gshadow') else None

    # Set permissions of home and root directories
    if os.path.exists(target + '/etc/passwd'):
        contents = open(target + '/etc/passwd', "r").read().rstrip().split(':')

        if contents[5].startswith('/') or contents[5] is None:
            if os.path.exists(target + contents[5]):
                execute_command("chown -hR -- {}:{} {}".format(contents[2], contents[3], target + contents[5]))
                execute_command("chmod -f 0750 -- {}".format(target + contents[5]))
            else:
                execute_command(
                    "install -d -m 0750 -o {} -g {} -- {}".format(contents[2], contents[3], target + contents[5]))

    logging.info("Custom airootfs generated successfully!")
    change_status("make_custom_airootfs")




def customize_airootfs():
    mount_operations("mount")
    
    root_directory = target + "/root/customize/"
    execute_command("mkdir -p {}".format(root_directory + "customize"))
	
    for source, file in iso_profile["customize_airootfs"].items():
        shutil.copyfile(file, root_directory + source)
        os.chmod(root_directory + source, 0o755)
	
        run_chroot("/root/customize/" + source)
        
    logging.info("Airootfs customized!")
    change_status("customize_airootfs")
         



def set_permissions():
    mount_operations("umount")
    
    for name, permission in iso_profile["file_permissions"].items():
        permission = permission.split(':')
        name = work_directory + '/' + iso_profile["arch"] + name

        execute_command("chown -fh -- {}:{} {}".format(permission[0], permission[1], name))
        execute_command("chmod -f -- {} {}".format(permission[2], name))
        
    logging.info("Permissions set!")
    change_status("set_permissions")


def cleanup():
    # Copy boot files before, removing initramfs
    execute_command("mkdir -p {}".format(work_directory + "/isowork/boot/grub"))
    execute_command("mkdir -p {}".format(work_directory + "/isowork/live"))
    execute_command("cp -prf \"{}\"/* \"{}\"/".format(target + "/boot", work_directory + "/isowork/boot"))

    remove_all_contents(target + "/var/lib/pacman/sync/*")
    remove_all_contents(target + "/var/log/*")
    remove_all_contents(target + "/var/tmp/*")
    execute_command("find \"{}/var/lib/pacman\" -maxdepth 1 -type f -delete".format(target),False)
    execute_command("find \"{}/var/cache/apt/archives\" -maxdepth 1 -type f -delete".format(target),False)
    if os.path.exists(target + "/root/customize"):
        shutil.rmtree(target + "/root/customize")

    open(target + "/etc/machine-id", 'w+').close()
    
    logging.info("Airootfs cleaned!")
    change_status("cleanup")


def prepare_squashfs():
    mount_operations("umount")
    execute_command("mksquashfs \"{}\" {}/airootfs.sfs -comp \"{}\" -wildcards".format(target, work_directory+"/isowork/live", compression_type))

    logging.info("Squashfs prepared!")
    change_status("prepare_squashfs")




def generate_iso():
    # Create Directories
    execute_command("mkdir -p {}/isowork/EFI/boot".format(work_directory))
    execute_command("mkdir -p {}/efiboot".format(work_directory))

    # Copy Necessary Directories
    execute_command("cp -r {}/usr/lib/grub/i386-pc/ {}/isowork/boot/grub/".format(target, work_directory),False)
    execute_command("cp -r {}/usr/lib/grub/i386-efi/ {}/isowork/boot/grub/".format(target, work_directory),False)
    execute_command("cp -r {}/usr/lib/grub/x86_64-efi/ {}/isowork/boot/grub/".format(target, work_directory),False)
    execute_command("cp -r {}/usr/share/grub/themes/ {}/isowork/boot/grub/".format(target, work_directory),False)

    # Generate Bootloaders
    execute_command("grub-mkimage -d {0}/isowork/boot/grub/i386-pc/ -o {0}/isowork/boot/grub/i386-pc/core.img -O i386-pc -p /boot/grub biosdisk iso9660".format(work_directory),False)
    execute_command("cat {0}/isowork/boot/grub/i386-pc/cdboot.img {0}/isowork/boot/grub/i386-pc/core.img > {0}/isowork/boot/grub/i386-pc/eltorito.img".format(work_directory),False)
    execute_command("grub-mkimage -d {0}/isowork/boot/grub/x86_64-efi/ -o {0}/isowork/EFI/boot/bootx64.efi -O x86_64-efi -p /boot/grub iso9660".format(work_directory),False)
    execute_command("grub-mkimage -d {0}/isowork/boot/grub/i386-efi/ -o {0}/isowork/EFI/boot/bootia32.efi -O i386-efi -p /boot/grub iso9660".format(work_directory),False)

    # Generate efi.img
    execute_command("truncate -s 4M {}/isowork/efi.img".format(work_directory))
    execute_command("mkfs.fat -n TEAISO_EFI {}/isowork/efi.img &>/dev/null".format(work_directory))
    execute_command("mount -o loop {0}/isowork/efi.img {0}/efiboot".format(work_directory))
    execute_command("mkdir -p {}/efiboot/EFI/boot".format(work_directory))
    execute_command("grub-mkimage -d {0}/isowork/boot/grub/x86_64-efi/ -o {0}/efiboot/EFI/boot/bootx64.efi -O x86_64-efi -p /boot/grub iso9660".format(work_directory),False)
    execute_command("grub-mkimage -d {0}/isowork/boot/grub/i386-efi/ -o {0}/efiboot/EFI/boot/bootia32.efi -O i386-efi -p /boot/grub iso9660".format(work_directory),False)
    execute_command("umount -fl {}/efiboot".format(work_directory))

    # Miscellaneous
    execute_command("grub-editenv {}/isowork/boot/grub/grubenv set menu_show_once=1".format(work_directory))

    # Xorriso
    modification_date = datetime.now().strftime("%Y-%m-%d-%H-%M-%S-00").replace("-", "")

    execute_command("""xorriso -as mkisofs \
                --modification-date={0} \
                --protective-msdos-label \
                -volid "{1}" \
                -appid "{2}" \
                -publisher "{3}" \
                -preparer "Prepared by TeaISO v{4}" \
                -r -graft-points -no-pad \
                --sort-weight 0 / \
                --sort-weight 1 /boot \
                --grub2-mbr {5}/isowork/boot/grub/i386-pc/boot_hybrid.img \
                -iso_mbr_part_type 0x00 \
                -partition_offset 16 \
                -b boot/grub/i386-pc/eltorito.img \
                -c boot.catalog \
                -no-emul-boot -boot-load-size 4 -boot-info-table --grub2-boot-info \
                -eltorito-alt-boot \
                -append_partition 2 0xef {5}/isowork/efi.img \
                -e --interval:appended_partition_2:all:: \
                -no-emul-boot \
                -full-iso9660-filenames \
                -iso-level 3 -rock -joliet \
                -o {6} \
                {5}/isowork/""".format(modification_date, iso_profile["label"], iso_profile["application_id"], iso_profile["publisher"], VERSION, work_directory, output_directory + "/" + iso_name))
    
    logging.info("ISO generated!")
    change_status("generate_iso")
    

def change_status(name):
    open(work_directory + "/" + name, 'a').close()


def check_status(name):
    if os.path.exists(work_directory):
        if not name in os.listdir(work_directory + "/"):
            return 1
    else:
        return 1
    

def mount_operations(type="mount"):
    if type == "mount":
        for dir in ["dev", "sys", "proc", "run", "dev/pts"]:
            execute_command("mount --bind /{0} {1}/{0}".format(dir,target))
    elif type == "umount":
        for dir in ["dev", "sys", "proc", "run", "dev/pts"]:
            while 0 == os.system("umount -lf -R {1}/{0}".format(dir,target)):
                True
    else:
        logging.error("Please select true type for mount operations!")
        sys.exit(1)


def show_verbose_profile():
    today = date.today()
    iso_name = iso_profile["name"] + "-" + today.strftime("%d-%m-%Y") + "-" + iso_profile["arch"] + ".iso"

    logging.info("mkteaiso configuration settings:")
    logging.info("                  Profile:   {}".format(iso_profile["name"]))
    logging.info("                    Label:   {}".format(iso_profile["label"]))
    logging.info("           Application ID:   {}".format(iso_profile["application_id"]))
    logging.info("            ISO publisher:   {}".format(iso_profile["publisher"]))
    logging.info("            ISO file name:   {}".format(iso_name))
    logging.info("       Airootfs directory:   {}".format(iso_profile["airootfs_directory"]))
    logging.info("        Working directory:   {}".format(work_directory))
    logging.info("         Output directory:   {}".format(output_directory))
    logging.info("Pacman configuration file:   {}".format(iso_profile["pacman_directory"]))
    logging.info("             Architecture:   {} ".format(iso_profile["arch"]))
    logging.info("               Build date:   {}".format(time.time()))
    logging.info("         File permissions:   {}".format(iso_profile["file_permissions"]))
    logging.info("       Customize Airootfs:   {}".format(iso_profile["customize_airootfs"]))
    logging.info("                 Packages:   {}\n".format(iso_profile["all_packages"]))


if __name__ == "__main__":


    cmd_line = arguments()
    # Clean env varibles
    os.environ.clear()


    # Set directories
    output_directory = os.path.realpath(cmd_line.output or 'output')
    work_directory = os.path.realpath(cmd_line.work or 'work')

    compression_type = cmd_line.compression or 'gzip'

    iso_profile = read_profile(cmd_line.profile)
    iso_name = iso_profile["name"] + "-" + date.today().strftime("%d-%m-%Y") + "-" + iso_profile["arch"] + ".iso"
    target = os.path.realpath(work_directory + "/" + iso_profile["arch"])

    if iso_profile["distro"] == 'debian':
        import debian as system
    elif iso_profile["distro"] == 'archlinux':
        import archlinux as system
    else:
        logging.error("Unsupported distro type detected")
        sys.exit(1)


    # Umount if already mounted. (for easy use rm -rf work output)
    mount_operations("umount")

    if cmd_line.verbose:
        logging.getLogger().setLevel(logging.INFO)
        show_verbose_profile()

    system.work_directory = work_directory
    system.iso_profile = iso_profile


    # Prepare & Generate ISO
    steps = ["create_directories" ,"system.make_pkg_conf", "mount_operations", "make_custom_airootfs", "system.install_packages", "customize_airootfs", 
             "system.make_pkglist", "set_permissions", "cleanup", "prepare_squashfs", "system.make_isowork"]
    
    for step in steps:
        if check_status(step):
            eval(step + "()")
        
    if check_status("generate_iso"):
        generate_iso()
    else:
        logging.error('ISO already created! If you want re-create ISO, you should remove work and output directories!')
        sys.exit(1)